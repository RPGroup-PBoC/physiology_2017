function gatedf = unsupervised_gating(df, frac, nbins, xVal, yVal, logScale)
% Automatically gates the data based on the density of the dat points on
% the xVal and yVal 2D histogram.
% Parameters
% ----------
% df : table
%     table containing the raw data to be gated. This must be a table object
%     since the name of the column will be used to decide on which columns
%     to apply the gate.
% frac : float. (0, 1).
%     fraction of the data to be kept after applying the gate. This should
%     be a number between 0 and 1.
% nbins : array. size (2, 1)
%     number of bins to use on the x axis and y axis.
% xVal : string.
%     Name of the column in df that contains the x values that will be used
%     for the gating.
% yVal : string.
%     Name of the column in df that contains the y values that will be used
%     for the gating.
% logScale : bool.
%     Boolean indicating if the gating should be performed using the log
%     of the indicated xVal and yVal values.
% Returns
% -------
% gateddf : table.
%     Table that keeps the values that passed the criteria applied by the
%     gating.
    
    % Determine the x and y values on which to perform the gating.
    % Check if the log scale should be applied or not.
    if logScale
        x = log(df(:, xVal));
        y = log(df(:, yVal));
    else
        x = df(:, xVal);
        y = df(:. yVal);
    end %if
    
    % Compute the 2D histogram keeping track of the bin counts and the
    % coordinates at which these bins exist
    [number, center] = hist3([x y], nbins);
    
    % extract the center of the bins into reasonable variables
    xCenter = [center{1}];
    yCenter = [center{2}];

    % Find non-zerio elements of the histogram to speed up the calculation.
    [nRow, nCol, nValue] = find(number);

    % Generate data frame with the x and y coordinate along with the bin
    % count for the non-zero bins
    dfSort = table([nRow, nCol, nValue],...
                    'VariableNames', {xVal, yVal, 'count'});

    % Sort the data frame by the bin count
    dfSort = sortrows(dfSort, 'count', 'descend');
    
    % Add column with cumulative fraction of data
    dfSort.cumfrac = dfSort.count / sum(dfSort.count);
    
    % define the inter-bin distance
    xbinDist = diff(fscCenter);
    xbinDist = xbinDist(1);
    ybinDist = diff(sscCenter);
    ybinDist = ybinDist(1);
 
    % Generate boolean array to know which bins to keep
    binsToKeep = dfsort.cumfrac <= frac;

    % Keep only the bins that satisfied the percentage condition
    dfKept = dfsort(binsToKeep, :);
    
    % Initialize an array to keep track of which data points we will keep
    idx = zeros([height(df), 1]);

    % generate a for loop to loop through each of the bins
    for i=1:height(dfKept)
        % Generate the box boundaries
        xva
        xbin = [dfKept(i, :).FSC - xbinDist / 2, dfKept(i, :).FSC + xbinDist / 2];
        ybin = [dfKept(i, :).SSC - ybinDist / 2, dfKept(i, :).SSC + ybinDist / 2];
        % Find which data points are inside the box
        [inBox, on] = inpolygon(df.logFSC, df.logSSC, xbin, ybin);
        % update the boolean array to know which data passed the filter
        idx = idx | inBox;
    end %for


end %function